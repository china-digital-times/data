{"id":170730,"link":"https://chinadigitaltimes.net/chinese/2011/08/阮一峰-jquery最佳实践/","date":"2011-08-06T17:00:26Z","modified":"2011-08-06T17:00:26Z","title":"阮一峰 | jQuery最佳实践","content":"<p><p>上周，我整理了<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html\">《jQuery设计思想》</a>。</p>\n<p>那篇文章是一篇入门教程，从设计思想的角度，讲解<strong>&#8220;怎么使用jQuery&#8221;</strong>。今天的文章则是更进一步，讲解<strong>&#8220;如何用好jQuery&#8221;</strong>。</p>\n<p>我主要参考了Addy Osmani的PPT<a rel=\"nofollow\" href=\"http://addyosmani.com/jqprovenperformance/\">《提高jQuery性能的诀窍》</a>（jQuery Proven Performance Tips And Tricks）。他是jQuery开发团队的成员，具有一定的权威性，提出的结论都有测试数据支持，非常有价值。</p>\n<p>==============================================</p>\n<p><strong>jQuery最佳实践</strong></p>\n<p>阮一峰 整理</p>\n<p><img src=\"http://image.beekka.com/blog/201108/bg2011080303.jpg\" /></p>\n<p><strong>1. 使用最新版本的jQuery</strong></p>\n<p>jQuery的版本更新很快，你应该总是使用最新的版本。因为新版本会改进性能，还有很多新功能。</p>\n<p>下面就来看看，不同版本的jQuery性能差异有多大。这里是三条最常见的jQuery选择语句：</p>\n<blockquote>\n<p> $(&#8216;.elem&#8217;)</p>\n<p> $(&#8216;.elem&#8217;, context)</p>\n<p> context.find(&#8216;.elem&#8217;)</p>\n</blockquote>\n<p>我们用1.4.2、1.4.4、1.6.2三个版本的jQuery<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-1-4-2-vs-1-6-2-comparisons\">测试</a>，看看浏览器在1秒内能够执行多少次。结果如下：</p>\n<p><img src=\"http://image.beekka.com/blog/201108/bg2011080301.png\" /></p>\n<p>可以看到，1.6.2版本的运行次数，远远超过两个老版本。尤其是第一条语句，性能有数倍的提高。</p>\n<p>其他语句的测试，比如<a rel=\"nofollow\" href=\"http://jsperf.com/attr-vs-attrhooks\">.attr(&#8220;value&#8221;)</a>和<a rel=\"nofollow\" href=\"http://jsperf.com/valhooks-vs-val/2\">.val()</a>，也是新版本的jQuery表现好于老版本。</p>\n<p><strong>2. 用对选择器</strong></p>\n<p>在jQuery中，你可以用多种选择器，选择同一个网页元素。每种选择器的性能是不一样的，你应该了解它们的性能差异。</p>\n<p><strong>（1）最快的选择器：id选择器和元素标签选择器</strong></p>\n<p>举例来说，下面的语句性能最佳：</p>\n<blockquote>\n<p> $(&#8216;#id&#8217;)</p>\n<p> $(&#8216;form&#8217;)</p>\n<p> $(&#8216;input&#8217;)</p>\n</blockquote>\n<p>遇到这些选择器的时候，jQuery内部会自动调用浏览器的原生方法（比如getElementById()），所以它们的执行速度快。</p>\n<p><strong>（2）较慢的选择器：class选择器</strong></p>\n<p>$(&#8216;.className&#8217;)的性能，取决于不同的浏览器。</p>\n<p>Firefox、Safari、Chrome、Opera浏览器，都有原生方法getElementByClassName()，所以速度并不慢。但是，IE5-IE8都没有部署这个方法，所以这个选择器在IE中会相当慢。</p>\n<p><strong>（3）最慢的选择器：伪类选择器和属性选择器</strong></p>\n<p>先来看例子。找出网页中所有的隐藏元素，就要用到伪类选择器：</p>\n<blockquote>\n<p> $(&#8216;:hidden&#8217;)</p>\n</blockquote>\n<p>属性选择器的例子则是：</p>\n<blockquote>\n<p> $(&#8216;[attribute=value]&#8217;)</p>\n</blockquote>\n<p>这两种语句是最慢的，因为浏览器没有针对它们的原生方法。但是，一些浏览器的新版本，增加了querySelector()和querySelectorAll()方法，因此会使这类选择器的性能有大幅提高。</p>\n<p>最后是不同选择器的<a rel=\"nofollow\" href=\"http://jsperf.com/dh-jquery-1-4-vs-1-6/6\">性能比较图</a>。</p>\n<p><img src=\"http://image.beekka.com/blog/201108/bg2011080302.png\" /></p>\n<p>可以看到，ID选择器遥遥领先，然后是标签选择器，第三是Class选择器，其他选择器都非常慢。</p>\n<p><strong>3. 理解子元素和父元素的关系</strong></p>\n<p>下面六个选择器，都是从父元素中选择子元素。你知道哪个速度最快，哪个速度最慢吗？</p>\n<blockquote>\n<p> $(&#8216;.child&#8217;, $parent)</p>\n<p> $parent.find(&#8216;.child&#8217;)</p>\n<p> $parent.children(&#8216;.child&#8217;)</p>\n<p> $(&#39;#parent > .child&#39;)</p>\n<p> $(&#8216;#parent .child&#8217;)</p>\n<p> $(&#8216;.child&#8217;, $(&#8216;#parent&#8217;))</p>\n</blockquote>\n<p>我们一句句来看。</p>\n<p><strong>(1) $(&#8216;.child&#8217;, $parent)</strong></p>\n<p>这条语句的意思是，给定一个DOM对象，然后从中选择一个子元素。jQuery会自动把这条语句转成$.parent.find(&#8216;child&#8217;)，这会导致一定的性能损失。它比最快的形式慢了5%-10%。</p>\n<p><strong>(2) $parent.find(&#8216;.child&#8217;)</strong></p>\n<p>这条是最快的语句。.find()方法会调用浏览器的原生方法（getElementById，getElementByName，getElementByTagName等等），所以速度较快。</p>\n<p><strong>(3) $parent.children(&#8216;.child&#8217;)</strong></p>\n<p>这条语句在jQuery内部，会使用$.sibling()和javascript的nextSibling()方法，一个个遍历节点。它比最快的形式大约慢50%。</p>\n<p><strong>(4) $(&#39;#parent > .child&#39;)</strong></p>\n<p>jQuery内部使用Sizzle引擎，处理各种选择器。Sizzle引擎的选择顺序是从右到左，所以这条语句是先选.child，然后再一个个过滤出父元素#parent，这导致它比最快的形式大约慢70%。</p>\n<p><strong>(5) $(&#8216;#parent .child&#8217;)</strong></p>\n<p>这条语句与上一条是同样的情况。但是，上一条只选择直接的子元素，这一条可以于选择多级子元素，所以它的速度更慢，大概比最快的形式慢了77%。</p>\n<p><strong>(6) $(&#8216;.child&#8217;, $(&#8216;#parent&#8217;))</strong></p>\n<p>jQuery内部会将这条语句转成$(&#8216;#parent&#8217;).find(&#8216;.child&#8217;)，比最快的形式慢了23%。</p>\n<p>所以，最佳选择是$parent.find(&#8216;.child&#8217;)。而且，由于$parent往往在前面的操作已经生成，jQuery会进行缓存，所以进一步加快了执行速度。</p>\n<p>具体的例子和比较结果，请看<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-selectors-context/2\">这里</a>。</p>\n<p><strong>4. 不要过度使用jQuery</strong></p>\n<p>jQuery速度再快，也无法与原生的javascript方法相比。所以有原生方法可以使用的场合，尽量避免使用jQuery。</p>\n<p>请看下面的例子，为a元素绑定一个处理点击事件的函数：</p>\n<blockquote>\n<p> $(&#8216;a&#8217;).click(function()</p>\n<p> <strong>alert($(this).attr(&#8216;id&#8217;));</strong></p>\n<p> );</p>\n</blockquote>\n<p>这段代码的意思是，点击a元素后，弹出该元素的id属性。为了获取这个属性，必须连续两次调用jQuery，第一次是$(this)，第二次是attr(&#8216;id&#8217;)。</p>\n<p>事实上，这种处理完全不必要。更正确的写法是，直接采用javascript原生方法，调用this.id：</p>\n<blockquote>\n<p> $(&#8216;a&#8217;).click(function()</p>\n<p> <strong>alert(this.id);</strong></p>\n<p> );</p>\n</blockquote>\n<p>根据<a rel=\"nofollow\" href=\"http://jsperf.com/el-attr-id-vs-el-id/2\">测试</a>，this.id的速度比$(this).attr(&#8216;id&#8217;)快了20多倍。</p>\n<p><strong>5. 做好缓存</strong></p>\n<p>选中某一个网页元素，是开销很大的步骤。所以，使用选择器的次数应该越少越好，并且尽可能缓存选中的结果，便于以后反复使用。</p>\n<p>比如，下面这样的写法就是糟糕的写法：</p>\n<blockquote>\n<p> jQuery(&#8216;#top&#8217;).find(&#8216;p.classA&#8217;);</p>\n<p> jQuery(&#8216;#top&#8217;).find(&#8216;p.classB&#8217;);</p>\n</blockquote>\n<p>更好的写法是：</p>\n<blockquote>\n<p> var cached = jQuery(&#8216;#top&#8217;);</p>\n<p> cached.find(&#8216;p.classA&#8217;);</p>\n<p> cached.find(&#8216;p.classB&#8217;);</p>\n</blockquote>\n<p>根据<a rel=\"nofollow\" href=\"http://jsperf.com/ns-jq-cached\">测试</a>，缓存比不缓存，快了2-3倍。</p>\n<p><strong>6. 使用链式写法</strong></p>\n<p>jQuery的一大特点，就是允许使用链式写法。</p>\n<blockquote>\n<p> $(&#8216;div&#8217;).find(&#8216;h3&#8217;).eq(2).html(&#8216;Hello&#8217;);</p>\n</blockquote>\n<p>采用链式写法时，jQuery自动缓存每一步的结果，因此比非链式写法要快。根据<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-chaining\">测试</a>，链式写法比（不使用缓存的）非链式写法，大约快了25%。</p>\n<p><strong>7. 事件的委托处理（Event Delegation）</strong></p>\n<p>javascript的事件模型，采用&#8221;冒泡&#8221;模式，也就是说，子元素的事件会逐级向上&#8221;冒泡&#8221;，成为父元素的事件。</p>\n<p>利用这一点，可以大大简化事件的绑定。比如，有一个表格（table元素），里面有100个格子（td元素），现在要求在每个格子上面绑定一个点击事件（click），请问是否需要将下面的命令执行100次？</p>\n<blockquote>\n<p> $(&#8220;td&#8221;).bind(&#8220;click&#8221;, function()</p>\n<p> $(this).toggleClass(&#8220;click&#8221;);</p>\n<p> );</p>\n</blockquote>\n<p>回答是不需要，我们只要把这个事件绑定在table元素上面就可以了，因为td元素发生点击事件之后，这个事件会&#8221;冒泡&#8221;到父元素table上面，从而被监听到。</p>\n<p>因此，这个事件只需要在父元素绑定1次即可，而不需要在子元素上绑定100次，从而大大提高性能。这就叫事件的&#8221;委托处理&#8221;，也就是子元素&#8221;委托&#8221;父元素处理这个事件。</p>\n<p>具体的写法有两种。第一种是采用.delegate()方法：</p>\n<blockquote>\n<p> $(&#8220;table&#8221;).delegate(&#8220;td&#8221;, &#8220;click&#8221;, function()</p>\n<p> $(this).toggleClass(&#8220;click&#8221;);</p>\n<p> );</p>\n</blockquote>\n<p>第二种是采用.live()方法：</p>\n<blockquote>\n<p> $(&#8220;table&#8221;).each(function()</p>\n<p> $(&#8220;td&#8221;, this).live(&#8220;click&#8221;, function()</p>\n<p> $(this).toggleClass(&#8220;click&#8221;);<br /> );<br /> });</p>\n</blockquote>\n<p>这两种写法基本等价。唯一的区别在于，.delegate()是当事件冒泡到指定的父元素时触发，.live()则是当事件冒泡到文档的根元素后触发，因此.delegate()比.live()稍快一点。此外，这两种方法相比传统的.bind()方法还有一个好处，那就是对动态插入的元素也有效，.bind()只对已经存在的DOM元素有效，对动态插入的元素无效。</p>\n<p>根据<a rel=\"nofollow\" href=\"http://jsperf.com/bind-vs-click/12\">测试</a>，委托处理比不委托处理，快了几十倍。在委托处理的<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-delegate-vs-live-table-test/2\">情况</a>下，.delegate()又比.live()大约快26%。</p>\n<p><strong>8. 少改动DOM结构</strong></p>\n<p>（1）改动DOM结构开销很大，因此不要频繁使用.append()、.insertBefore()和.insetAfter()这样的方法。</p>\n<p>如果要插入多个元素，就先把它们合并，然后再一次性插入。根据<a rel=\"nofollow\" href=\"http://jsperf.com/string-concat-single-append-vs-multiple-append\">测试</a>，合并插入比不合并插入，快了将近10倍。</p>\n<p>（2）如果你要对一个DOM元素进行大量处理，应该先用.detach()方法，把这个元素从DOM中取出来，处理完毕以后，再重新插回文档。根据<a rel=\"nofollow\" href=\"http://jsperf.com/to-detach-or-not-to-detach\">测试</a>，使用.detach()方法比不使用时，快了60%。</p>\n<p>（3）如果你要在DOM元素上储存数据，不要写成下面这样：</p>\n<blockquote>\n<p> var elem = $(&#8216;#elem&#8217;);</p>\n<p> <strong>elem.data(key,value);</strong></p>\n</blockquote>\n<p>而要写成</p>\n<blockquote>\n<p> var elem = $(&#8216;#elem&#8217;);</p>\n<p> <strong>$.data(elem,key,value);</strong></p>\n</blockquote>\n<p>根据<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-data-vs-jqueryselection-data/11\">测试</a>，后一种写法要比前一种写法，快了将近10倍。因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用，所以速度快得多。（此处可以参阅下面第10点。）</p>\n<p><strong>9. 正确处理循环</strong></p>\n<p>循环总是一种比较耗时的操作，如果可以使用复杂的选择器直接选中元素，就不要使用循环，去一个个辨认元素。</p>\n<p>javascript原生循环方法for和while，要比jQuery的.each()方法<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-each-vs-for-loop/24\">快</a>，应该优先使用原生方法。</p>\n<p><strong>10. 尽量少生成jQuery对象</strong></p>\n<p>每当你使用一次选择器（比如$(&#8216;#id&#8217;)），就会生成一个jQuery对象。jQuery对象是一个很庞大的对象，带有很多属性和方法，会占用不少资源。所以，尽量少生成jQuery对象。</p>\n<p>举例来说，许多jQuery方法都有两个版本，一个是供<strong>jQuery对象</strong>使用的版本，另一个是供<strong>jQuery函数</strong>使用的版本。下面两个例子，都是取出一个元素的文本，使用的都是text()方法。你既可以使用针对jQuery对象的版本：</p>\n<blockquote>\n<p> var $text = $(&#8220;#text&#8221;);</p>\n<p> <strong>var $ts = $text.text();</strong></p>\n</blockquote>\n<p>也可以使用针对jQuery函数的版本：</p>\n<blockquote>\n<p> var $text = $(&#8220;#text&#8221;);</p>\n<p> <strong>var $ts = $.text($text);</strong></p>\n</blockquote>\n<p>由于后一种针对jQuery函数的版本不通过jQuery对象操作，所以相对开销较小，速度<a rel=\"nofollow\" href=\"http://jsperf.com/jquery-text-vs-html/5\">比较快</a>。</p>\n<p>（完）\n</p>\n<div>\n<h3>文档信息</h3>\n<ul>\n<li>版权声明：自由转载-非商用-非衍生-保持署名 | <a rel=\"nofollow\" href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\">Creative Commons BY-NC-ND 3.0</a></li>\n<li>原文网址：<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html\">http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html</a></li>\n<li>最后修改时间：2011年8月 4日 16:06</li>\n<li>付费支持（<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/05/my_google_adsense_is_disabled.html\">说明</a>）：<a rel=\"nofollow\" href=\"https://lab.alipay.com/p.htm?id=2011051700196144\"><img alt=\"支付宝担保交易\" src=\"http://chinadigitaltimes.net/chinese/files/2011/08/3a976ef2rmb_32.png.png\" /></a> | <a rel=\"nofollow\" href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&#038;business=yifeng.ruan@gmail.com&#038;currency_code=USD&#038;amount=0.3&#038;return=http://www.ruanyifeng.com/thank.html&#038;item_name=Ruan%20YiFeng's%20Blog&#038;undefined_quantity=1&#038;no_note=0\"><img alt=\"paypal\" src=\"http://chinadigitaltimes.net/chinese/files/2011/08/5ca83e43dollar_32.png.png\" /></a> </li>\n</ul>\n</div>\n<p><img src=\"http://chinadigitaltimes.net/chinese/files/2011/08/872d7657g2011080303.jpg-150x150.jpg\" /></p>\n<p><small>本文由自动聚合程序取自网络，内容和观点不代表数字时代立场</small></p>\n<form method=\"POST\" action=\"http://www.feedblitz.com/f/f.fbz?AddNewUserDirect\">\n定期获得翻墙信息？<a href=\"http://www.feedblitz.com/f/?Sub=738338\">请电邮订阅数字时代</a> <br /><input name=\"EMAIL\" maxlength=\"64\" type=\"text\" size=\"25\" value=\"\"><br />\n<input name=\"FEEDID\" type=\"hidden\" value=\"738338\"><br />\n<input name=\"PUBLISHER\" type=\"hidden\" value=\"7485568\"><br />\n<input type=\"submit\" value=\"订阅!\"><br />\n</form>\n","author":440,"categories":[9203],"tags":[9400]}